use std::str::FromStr;
use lalrpop_util::{lexer, ErrorRecovery, ParseError};
use crate::syntax::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, lexer::Token<'input>, &'static str>>);

pub Module: Module = {
    <decls: Decl*> => Module { decls },
}

pub Decl: Decl = {
    TypeDecl => Decl::Type(<>),
    FuncDecl => Decl::Func(<>),
}

TypeDecl: TypeDecl = {
    "type" <name: TypeVar> <params: TypeParams> "=" <body: Type> =>
        TypeDecl { name, params, body },
}

FuncDecl: FuncDecl = {
    "fn" <name: ExprVar> <type_params: TypeParams> "(" <expr_params: List0<Param<TypeAnn>, ",">> ")" "->" <return_type: Type> <body: BlockExpr> =>
        FuncDecl { name, type_params, expr_params, return_type, body },
}

TypeParams: Vec<TypeVar> = {
    => vec![],
    "<" <List1<TypeVar, ",">> ">",
}

pub Type: Type = {
    TypeVar => Type::Var(<>),
    "(" <List0<Type, ",">> ")" "->" <Box<Type>> => Type::Fun(<>),
    <TypeVar> "<" <List1<Type, ",">> ">" => Type::SynApp(<>),
    "{" <List0<Param<TypeAnn>, ",">> "}" => Type::Record(<>),
    "[" <List1<VariantCaseType, "|">> "]" => Type::Variant(<>),
    ! => { errors.push(<>); Type::Error },
}

VariantCaseType: (ExprCon, Option<Type>) = {
    ExprCon InParens<Type>? => (<>),
}

pub Expr: Expr = {
    SumExpr,
    BinOp<SumExpr, CompOp, SumExpr>,
    "fn" "(" <List0<Param<OptTypeAnn>, ",">> ")" <Box<BlockExpr>> => Expr::Lam(<>),
    "if" <Box<Expr>> <Box<BlockExpr>> "else" <Box<BlockExpr>> => Expr::If(<>),
    "match" <Box<Expr>> "{" <Branch+> "}" => Expr::Match(<>),
}

pub BlockExpr: Expr = {
    "{" <Statements> "}",
}

Statements: Expr = {
    Expr,
    "let" <ExprVar> <OptTypeAnn> "=" <Box<Expr>> ";" <Box<Statements>> => Expr::Let(<>),
    "let" <ExprVar> <OptTypeAnn> "=" <Box<BlockExpr>> ";" <Box<Statements>> => Expr::Let(<>),
}

SumExpr: Expr = {
    BinOp<SumExpr, SumOp, ProductExpr>,
    ProductExpr,
}

ProductExpr: Expr = {
    BinOp<ProductExpr, ProductOp, AtomExpr>,
    AtomExpr,
}

AtomExpr: Expr = {
    InParens<Expr>,
    ExprVar => Expr::Var(<>),
    Num => Expr::Num(<>),
    Bool => Expr::Bool(<>),
    // TODO(MH): Merge the two rules below.
    <fun: ExprVar> "(" <args: List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::Var(fun)), args),
    // NOTE(MH): Ideally, we would not have the "@" symbol before the angle
    // brackets, but that would make the expression `f(g<a, b>(c))` ambiguous
    // to parse. With `f(g@<a, b>(c))` there's no ambiguity.
    <fun: ExprVar> "@" "<" <types: List1<Type, ",">> ">" "(" <args: List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::FunInst(fun, types)), args),
    "{" <List0<RecordAssign, ",">> "}" => Expr::Record(<>),
    <Box<AtomExpr>> "." <ExprVar> => Expr::Proj(<>),
    <ExprCon> <Box<InParens<Expr>>?> => Expr::Variant(<>),
    ! => { errors.push(<>); Expr::Error },
}

TypeAnn: Type = {
    ":" <Type>,
}

OptTypeAnn: Option<Type> = {
    => None,
    ":" <Type> => Some(<>),
}

Param<T>: (ExprVar, T) = {
    ExprVar T => (<>),
}

RecordAssign: (ExprVar, Expr) = {
    <ExprVar> "=" <Expr> => (<>),
}

Branch: Branch = {
    <con: ExprCon> <var: InParens<ExprVar>?> "=>" <rhs: BlockExpr> => Branch { con, var, rhs },
    <con: ExprCon> <var: InParens<ExprVar>?> "=>" <rhs: Expr> "," => Branch { con, var, rhs },
}

TypeVar: TypeVar = {
    ID_UPPER => TypeVar::new(<>),
}

ExprVar: ExprVar = {
    ID_LOWER => ExprVar::new(<>),
}

ExprCon: ExprCon = {
    ID_UPPER => ExprCon::new(<>),
}

Num: i64 = {
    NUMBER =>? i64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number literal is too big"
        })
};

Bool: bool = {
    "false" => false,
    "true" => true,
}

SumOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
}

ProductOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
}

CompOp: OpCode = {
    "==" => OpCode::Equals,
    "!=" => OpCode::NotEq,
    "<" => OpCode::Less,
    "<=" => OpCode::LessEq,
    ">" => OpCode::Greater,
    ">=" => OpCode::GreaterEq,
}

Box<T>: Box<T> = {
    <T> => Box::new(<>),
}

List0<T, Sep>: Vec<T> = {
    => Vec::new(),
    List1<T, Sep>,
}

List1<T, Sep>: Vec<T> = {
    <ts: (<T> Sep)*> <t: T> Sep? => {
        let mut ts = ts;
        ts.push(t);
        ts
    },
}

BinOp<X, Op, Y>: Expr = {
    <x: Box<X>> <op: Op> <y: Box<Y>> => Expr::BinOp(<>),
}

InParens<X>: X = {
    "(" <X> ")",
}

match {
    "type",
    "fn",
    "let",
    "if",
    "else",
    "match",
    "true",
    "false",
    r"[A-Z]\w*" => ID_UPPER,
    r"[a-z]\w*" => ID_LOWER,
    r"[0-9]+" => NUMBER,
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // Skip `/* comments */`
    _
}
