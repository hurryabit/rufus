use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::syntax::*;

grammar;

pub Module: Module = {
    <decls: Decl*> => Module { decls },
}

pub Decl: Decl = {
    TypeDecl => Decl::Type(<>),
    FuncDecl => Decl::Func(<>),
}

TypeDecl: TypeDecl = {
    "type" <name: TypeVar> <params: TypeParams> "=" <rhs: Box<Type>> =>
        TypeDecl { name, body: Type::Abs(params, rhs) },
}

FuncDecl: FuncDecl = {
    "fn" <name: ExprVar> <type_params: TypeParams> "(" <expr_params: List0<Param<TypeAnn>, ",">> ")" "->" <return_type: Type> <body: BlockExpr> =>
        FuncDecl { name, type_params, expr_params, return_type, body },
}

TypeParams: Vec<TypeVar> = {
    => vec![],
    "<" <List1<TypeVar, ",">> ">" => <>,
}

pub Type: Type = {
    TypeVar => Type::Var(<>),
    "(" <List0<Type, ",">> ")" "->" <Box<Type>> => Type::Fun(<>),
    <TypeVar> "<" <List1<Type, ",">> ">" => Type::App(<>),
    "{" <List0<Param<TypeAnn>, ",">> "}" => Type::Record(<>),
    "[" <List1<VariantCaseType, "|">> "]" => Type::Variant(<>),
}

VariantCaseType: (ExprCon, Option<Type>) = {
    ExprCon InParens<Type>? => (<>),
}

pub Expr: Expr = {
    SumExpr,
    BinOp<SumExpr, CompOp, SumExpr>,
    // TODO(MH): Merge the two rules below.
    "fn" "(" <List0<Param<OptTypeAnn>, ",">> ")" <Box<BlockExpr>> => Expr::Lam(<>),
    "fn" "<" <tyvars: List1<TypeVar, ",">> ">" "(" <exvars: List0<Param<OptTypeAnn>, ",">> ")" <body: Box<BlockExpr>> => Expr::TypeAbs(tyvars, Box::new(Expr::Lam(exvars, body))),
    "if" <Box<Expr>> <Box<BlockExpr>> "else" <Box<BlockExpr>> => Expr::If(<>),
    "match" <Box<Expr>> "{" <Branch+> "}" => Expr::Match(<>),
}

pub BlockExpr: Expr = {
    "{" <Statements> "}" => <>,
}

Statements: Expr = {
    Expr => <>,
    "let" <ExprVar> <OptTypeAnn> "=" <Box<Expr>> ";" <Box<Statements>> => Expr::Let(<>),
    "let" <ExprVar> <OptTypeAnn> "=" <Box<BlockExpr>> ";" <Box<Statements>> => Expr::Let(<>),
}

SumExpr: Expr = {
    BinOp<SumExpr, SumOp, ProductExpr>,
    ProductExpr,
}

ProductExpr: Expr = {
    BinOp<ProductExpr, ProductOp, AtomExpr>,
    AtomExpr,
}

AtomExpr: Expr = {
    InParens<Expr> => <>,
    ExprVar => Expr::Var(<>),
    Num => Expr::Num(<>),
    Bool => Expr::Bool(<>),
    // TODO(MH): Merge the two rules below.
    <fun: ExprVar> "(" <args: List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::Var(fun)), args),
    // NOTE(MH): Ideally, we would not have the "@" symbol before the angle
    // brackets, but that would make the expression `f(g<a, b>(c))` ambiguous
    // to parse. With `f(g@<a, b>(c))` there's no ambiguity.
    <fun: ExprVar> "@" "<" <tyargs: List1<Type, ",">> ">" "(" <exargs: List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::TypeApp(Box::new(Expr::Var(fun)), tyargs)), exargs),
    "{" <List0<RecordAssign, ",">> "}" => Expr::Record(<>),
    <Box<AtomExpr>> "." <ExprVar> => Expr::Proj(<>),
    <ExprCon> <Box<InParens<Expr>>?> => Expr::Variant(<>),
}

TypeAnn: Type = {
    ":" <Type> => <>,
}

OptTypeAnn: Option<Type> = {
    => None,
    ":" <Type> => Some(<>),
}

Param<T>: (ExprVar, T) = {
    ExprVar T => (<>),
}

RecordAssign: (ExprVar, Expr) = {
    <ExprVar> "=" <Expr> => (<>),
}

Branch: Branch = {
    <con: ExprCon> <var: InParens<ExprVar>?> "=>" <rhs: BlockExpr> => Branch { con, var, rhs },
    <con: ExprCon> <var: InParens<ExprVar>?> "=>" <rhs: Expr> "," => Branch { con, var, rhs },
}

TypeVar: TypeVar = {
    r"[A-Z]\w*" => TypeVar::new(<>),
}

ExprVar: ExprVar = {
    r"[a-z]\w*" => ExprVar::new(<>),
}

ExprCon: ExprCon = {
    r"[A-Z]\w*" => ExprCon::new(<>),
}

Num: i64 = {
    r"[0-9]+" =>? i64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number literal is too big"
        })
};

Bool: bool = {
    "false" => false,
    "true" => true,
}

SumOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
}

ProductOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
}

CompOp: OpCode = {
    "==" => OpCode::Equals,
    "!=" => OpCode::NotEq,
    "<" => OpCode::Less,
    "<=" => OpCode::LessEq,
    ">" => OpCode::Greater,
    ">=" => OpCode::GreaterEq,
}

Box<T>: Box<T> = {
    <T> => Box::new(<>),
}

List0<T, Sep>: Vec<T> = {
    => Vec::new(),
    List1<T, Sep> => <>,
}

List1<T, Sep>: Vec<T> = {
    <ts: (<T> Sep)*> <t: T> Sep? => {
        let mut ts = ts;
        ts.push(t);
        ts
    },
}

BinOp<X, Op, Y>: Expr = {
    <x: Box<X>> <op: Op> <y: Box<Y>> => Expr::BinOp(<>),
}

InParens<X>: X = {
    "(" <X> ")" => <>,
}
