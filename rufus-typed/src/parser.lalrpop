use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::syntax::*;

grammar;

pub Type: Type  = {
    TypeVarName => Type::Var(<>),
    "Int" => Type::Int,
    "Bool" => Type::Bool,
    TypeConName => Type::Synonym(<>),
    "(" <List0<Type, ",">> ")" "->" <Box<Type>> => Type::Fun(<>),
    <TypeConName> "<" <List1<Type, ",">> ">" => Type::App(<>),
    "{" <List0<RecordFieldType, ",">> "}" => Type::Record(<>),
    "[" <List1<VariantCaseType, "|">> "]" => Type::Variant(<>),
}

TypeInParens: Type = {
    "(" <Type> ")" => <>,
}

RecordFieldType: (Name, Type) = {
    <ExprVarName> ":" <Type> => (<>),
}

VariantCaseType: (Name, Option<Type>) = {
    ExprConName TypeInParens? => (<>),
}

pub Expr: Expr = {
    SumExpr,
    BinOp<SumExpr, CompOp, SumExpr>,
}

BlockExpr: Expr = {
    "{" <Statements> "}" => <>,
}

Statements: Expr = {
    Expr => <>,
    "let" <ExprVarName> <OptTypeAnn> "=" <Box<Expr>> ";" <Box<Statements>> => Expr::Let(<>),
    "let" <ExprVarName> <OptTypeAnn> "=" <Box<BlockExpr>> ";" <Box<Statements>> => Expr::Let(<>),
}

SumExpr: Expr = {
    BinOp<SumExpr, SumOp, ProductExpr>,
    ProductExpr,
}

ProductExpr: Expr = {
    BinOp<ProductExpr, ProductOp, AtomExpr>,
    AtomExpr,
}

AtomExpr: Expr = {
    ExprInParens => <>,
    ExprVarName => Expr::Var(<>),
    Num => Expr::Num(<>),
    Bool => Expr::Bool(<>),
    // TODO(MH): Merge the two rules below.
    "fn" "(" <List0<Param<OptTypeAnn>, ",">> ")" <Box<BlockExpr>> => Expr::Lam(<>),
    "fn" "<" <tyvars: List1<TypeVarName, ",">> ">" "(" <exvars: List0<Param<OptTypeAnn>, ",">> ")" <body: Box<BlockExpr>> => Expr::TypeAbs(tyvars, Box::new(Expr::Lam(exvars, body))),
    // TODO(MH): Merge the two rules below.
    <fun: ExprVarName> "(" <args: List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::Var(fun)), args),
    // NOTE(MH): Ideally, we would not have the "@" symbol before the angle
    // brackets, but that would make the expression `f(g<a, b>(c))` ambiguous
    // to parse. With `f(g@<a, b>(c))` there's no ambiguity.
    <fun: ExprVarName> "@" "<" <tyargs: List1<Type, ",">> ">" "(" <exargs: List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::TypeApp(Box::new(Expr::Var(fun)), tyargs)), exargs),
    "if" <Box<Expr>> <Box<BlockExpr>> "else" <Box<BlockExpr>> => Expr::If(<>),
    "{" <List0<RecordAssign, ",">> "}" => Expr::Record(<>),
    <Box<AtomExpr>> "." <ExprVarName> => Expr::Proj(<>),
    <ExprConName> <Box<ExprInParens>?> => Expr::Variant(<>),
}

ExprInParens: Expr = {
    "(" <Expr> ")" => <>,
}

OptTypeAnn: Option<Type> = {
    => None,
    ":" <Type> => Some(<>),
}

Param<T>: (Name, T) = {
    ExprVarName T => (<>),
}

RecordAssign: (Name, Expr) = {
    <ExprVarName> "=" <Expr> => (<>),
}

TypeVarName: Name = {
    r"[a-z]\w*" => <>.to_string(),
}

TypeConName: Name = {
    r"[A-Z]\w*" => <>.to_string(),
}

ExprVarName: Name = {
    r"[a-z]\w*" => <>.to_string(),
}

ExprConName: Name = {
    r"[A-Z]\w*" => <>.to_string(),
}

Num: i64 = {
    r"[0-9]+" =>? i64::from_str(<>)
        .map_err(|_| ParseError::User {
            error: "number literal is too big"
        })
};

Bool: bool = {
    "false" => false,
    "true" => true,
}

SumOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
}

ProductOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
}

CompOp: OpCode = {
    "==" => OpCode::Equals,
    "!=" => OpCode::NotEq,
    "<" => OpCode::Less,
    "<=" => OpCode::LessEq,
    ">" => OpCode::Greater,
    ">=" => OpCode::GreaterEq,
}

Box<T>: Box<T> = {
    <T> => Box::new(<>),
}

List0<T, Sep>: Vec<T> = {
    => Vec::new(),
    List1<T, Sep> => <>,
}

List1<T, Sep>: Vec<T> = {
    <ts: (<T> Sep)*> <t: T> Sep? => {
        let mut ts = ts;
        ts.push(t);
        ts
    },
}

BinOp<X, Op, Y>: Expr = {
    <x: Box<X>> <op: Op> <y: Box<Y>> => Expr::BinOp(<>),
}
