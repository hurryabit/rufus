use std::str::FromStr;

use crate::syntax::*;

grammar;

pub Expr: Expr = {
    <SumExpr>,
    "fun" "(" <List0<Name, ",">> ")" "->" <Box<Expr>> => Expr::Lam(<>),
    "let" <Name> "=" <Box<Expr>> "in" <Box<Expr>> => Expr::Let(<>),
    "match" <scrutinee:Box<Expr>> "with" <branches:MatchBranch+> "end" => {
        let branches = branches
            .into_iter()
            .map(|(t, b, e)| (t, (b, e)))
            .collect();
        Expr::Match(scrutinee, branches)
    },
};

SumExpr: Expr = {
    <x:Box<SumExpr>> <op:SumOp> <y:Box<ProductExpr>> => Expr::Op(op, x, y),
    ProductExpr,
}

ProductExpr: Expr = {
    <x:Box<ProductExpr>> <op:ProductOp> <y:Box<AtomExpr>> => Expr::Op(op, x, y),
    AtomExpr,
}

AtomExpr: Expr = {
    Name => Expr::Var(<>, None),
    Num => Expr::Num(<>),
    <f:Name> "(" <xs:List0<Expr, ",">> ")" => Expr::App(Box::new(Expr::Var( f, None)), xs),
    "print" "(" <Box<Expr>> ")" => Expr::Print(<>),
    "(" <Expr> ")",
    "{" <List0<RecordAssign, ";">> "}" => Expr::Record(<>),
    <Box<AtomExpr>> "." <Name> => Expr::Proj(<>),
    <Tag> "(" <Box<Expr>> ")" => Expr::Variant(<>),
};

RecordAssign: (Name, Expr) = {
    <Name> "=" <Expr> => (<>)
}

MatchBranch: (Name, Name, Expr) = {
    "|" <Tag> "(" <Name> ")" "->" <Expr> => (<>)
}

Name: Name = {
    r"[a-z]\w*" => Name(<>.to_string())
};

Tag: Name = {
    r"[A-Z]\w*" => Name(<>.to_string())
}

Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};

SumOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
}

ProductOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
}

Box<T>: Box<T> = {
    <T> => Box::new(<>)
}

List0<T, Sep>: Vec<T> = {
    => Vec::new(),
    <ts:(<T> Sep)*> <t:T> => {
        let mut ts = ts;
        ts.push(t);
        ts
    }
}
